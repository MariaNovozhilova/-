#!/usr/bin/env python
# coding: utf-8

# Задача:
# 
# 
# Компания ПЭК тестирует доставку последней мили с помощью автономных
# роботов-доставщиков. На сортировочном центре в черте города роботу загружают
# посылку (помещается только одна), далее робот отправляется по адресу, где его
# встречает получатель и забирает посылку. Для доставки следующей посылки робот
# возвращается на сортировочный центр.
# Сортировочный центр обслуживает район города, очерченный окружностью радиуса R.
# Для простоты расчетов будем считать, что клиенты по этой площади распределены
# равномерно, а робот двигается к клиенту вдоль радиуса. Скорость движения робота
# постоянна = v. Временем, необходимым на загрузку и разгрузку посылки, можно
# пренебречь.
# 
# Вопрос: Как связано количество посылок, которое успеет доставить робот за день и предельная дальность доставки R? 
# - Ответ: Чем больше R, тем меньше количество посылок за день успеет доставить робот.
# 
# Вопрос: Сделайте оценку среднего количества доставок за день с указанием всех значимых констант. Приложите не только ответ, но и ход решения.

# Решение
# 
# все единицы измерения условны

# In[1]:


import random


# In[2]:


# радиус окружности
R = 5 #(km)
# скорость движения робота
v = 5 #(km/h)
# продолжительность рабочего дня
H = 9 #(h)


# In[3]:


# воспользуюсь готовой функцией для генерации координат равномерно распределенных точек внутри окружности,
#включая границу (из статьи https://habr.com/ru/articles/583838/), перепишу функцию для любого радиуса R:

def rejection_sampling():
    while True:
        x = random.random() * 2 * R - R
        y = random.random() * 2 * R - R
        if x * x + y * y <= R:
            return x, y


# In[4]:


print(rejection_sampling())


# In[5]:


x, y = rejection_sampling()[0], rejection_sampling()[1]

# r - расстояние до произвольной точки внутри окружности (растояние до клиента)
r = (x**2 + y**2)** (1/2)

# t - время прохождения до точки и обратно (время одной доставки)
t = 2 * r / v

# q - количество доставок в день = продолжительность рабочего дня, деленная на время одной доставки


# Посчитаем случайное количество доставок за произвольное количество рабочих дней:

# In[6]:


# функция считает среднее количество доставок в день за заданное количество дней
# алгоритм: складываем время доставок до случайных координат, пока суммарное время не превысит количество рабочих часов 
# в заданное количество дней 

def avg_deliveries_number(days):
    q = 0 #количество доставок
    T = 0 #суммарное время нескольких доставок
    L = H*days #рабочее время за все дни
    while T <= L: #в цикле считаем доставки, пока не закончилось рабочее время 
        x, y = rejection_sampling()[0], rejection_sampling()[1]
        r = (x**2 + y**2)** (1/2)
        t = 2 * r / v
        T += t
        q += 1
    return (q - 1)/days


# In[7]:


print(avg_deliveries_number(300))

